{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}

module CCEA.EATest
  (
    testsEA
  ) where

import Test.HUnit

import NN.NeuralNetwork
import RandomUtil.Random
import CCEA.EA
import CCEA.XOR

import System.Random
import System.Random.Shuffle
import qualified Data.Map.Strict as Map
import Numeric.LinearAlgebra.HMatrix hiding (corr)
import AI.HNN.FF.Network

import Data.List (sortOn, partition)
         
-- Testing EA requires a selection strategy, a fitness function, and a breeding strategy

    

initialPop :: IO [Network Double]
initialPop = sequence $ map (\_ -> create nnVars) [1..1000]

myEA ::IO (EA (Network Double) Double)
myEA = do
  g <- getStdGen
  pop <- initialPop
  return $ EA pop (xorSelectionStrategy g) (xorFitnessFunction nnVars) (xorBreedingStrategy nnVars g)

bestNetwork :: [Network Double] -> Network Double
bestNetwork nets = let popWithFit = zip nets $ map (xorFitnessFunction nnVars) nets
                   in fst $ head $ reverse $ sortOn snd popWithFit
test1 :: Test
test1 = TestCase (do
                     g <- getStdGen
                     ea@(EA initPop _ _ _)  <- myEA 
                     let initialBestNet = bestNetwork initPop
                     putStrLn "\n-------------------"
                     mapM_ (print . output initialBestNet sigmoid . fromList) [[0.0,0.0],[0.0,1.0],[1.0,0.0],[1.0,1.0]]
                     putStrLn $ show (getWeights initialBestNet)
                     let (EA finalPop _ _ _) = evolveN 500 ea
                     let finalBestNet = bestNetwork finalPop
                     putStrLn "\n------------------"
                     mapM_ (print . output finalBestNet sigmoid . fromList) [[0.0,0.0],[0.0,1.0],[1.0,0.0],[1.0,1.0]]
                     putStrLn $ show (getWeights finalBestNet)
                     assertEqual "string" False True)


testsEA :: Test
testsEA = TestList [TestLabel "test1" test1]
